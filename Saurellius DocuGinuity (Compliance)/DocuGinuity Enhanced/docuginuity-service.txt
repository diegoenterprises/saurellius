/**
 * DocumentFetchService - Core service for document retrieval and management
 * 
 * Enhanced from the original Saurellius document fetching system with:
 * - Intelligent caching and versioning
 * - AI-powered document classification
 * - Multi-source prioritization and fallback
 * - Automatic retry and error handling
 */
class DocumentFetchService {
  constructor() {
    this.supportedSources = ['federal', 'state', 'territory', 'local'];
    this.httpClient = new HTTPClient();
    
    // Enhanced scrapers with machine learning capabilities
    this.scrapers = {
      default: new EnhancedWebScraper(),
      irs: new IRSScraper(),
      ssa: new SSAScraper(),
      dol: new DOLScraper(),
      uscis: new USCISScraper(),
      state: new StateGovScraper()
    };
    
    // Document repository for storage and retrieval
    this.repository = new DocumentRepository();
    
    // AI-powered document processor
    this.documentProcessor = new DocumentProcessor();
  }
  
  /**
   * Fetch a specific document by ID from the appropriate source
   */
  async fetchDocument(formId, jurisdiction, agency) {
    try {
      // Generate request ID for tracking
      const requestId = this._generateRequestId();
      console.log(`[${requestId}] Fetching document ${formId} from ${jurisdiction}/${agency}`);
      
      // Check cache first
      const cachedDocument = await this._checkDocumentCache(formId, jurisdiction, agency);
      if (cachedDocument) {
        console.log(`[${requestId}] Cache hit for ${formId}`);
        return cachedDocument;
      }
      
      // Determine the correct source configuration
      const sourceConfig = this._getSourceConfig(jurisdiction, agency);
      
      if (!sourceConfig) {
        throw new DocumentFetchError(
          'source_not_found',
          `No source configuration found for ${jurisdiction}/${agency}`,
          { formId, jurisdiction, agency }
        );
      }
      
      // Try multiple fetch methods with intelligent fallback
      let document;
      
      // Attempt API-based retrieval first
      if (sourceConfig.apiEndpoint) {
        try {
          document = await this._fetchFromApi(sourceConfig.apiEndpoint, formId, requestId);
        } catch (apiError) {
          console.log(`[${requestId}] API fetch failed: ${apiError.message}. Attempting fallback.`);
          // Continue to fallbacks
        }
      }
      
      // Try web scraping as fallback if API fails or isn't available
      if (!document) {
        try {
          document = await this._fetchFromWebsite(sourceConfig.baseUrl, formId, jurisdiction, agency, requestId);
        } catch (scrapingError) {
          console.log(`[${requestId}] Web scraping failed: ${scrapingError.message}. Attempting fallback.`);
          // Continue to fallbacks
        }
      }
      
      // Try archived/historical data as final fallback
      if (!document) {
        try {
          document = await this._fetchFromArchive(formId, jurisdiction, agency, requestId);
        } catch (archiveError) {
          console.log(`[${requestId}] Archive fetch failed: ${archiveError.message}.`);
          throw new DocumentFetchError(
            'document_not_found',
            `Could not fetch document ${formId} from any source`,
            { formId, jurisdiction, agency, requestId }
          );
        }
      }
      
      // Process and enhance the document
      const processedDocument = await this._processDocument(document, formId, jurisdiction, agency, requestId);
      
      // Store in cache for future requests
      await this._cacheDocument(processedDocument);
      
      return processedDocument;
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'fetch_error',
          `Error fetching document ${formId} from ${jurisdiction}/${agency}: ${error.message}`,
          { formId, jurisdiction, agency }
        );
      }
    }
  }
  
  /**
   * Get document metadata without fetching the full document
   */
  async getDocumentMetadata(formId, jurisdiction, agency) {
    try {
      return await this.repository.getDocumentMetadata(formId, jurisdiction, agency);
    } catch (error) {
      throw new DocumentFetchError(
        'metadata_error',
        `Error getting metadata for ${formId} from ${jurisdiction}/${agency}: ${error.message}`,
        { formId, jurisdiction, agency }
      );
    }
  }
  
  /**
   * List available documents matching specific filters
   */
  async listDocuments(filters, page = 1, pageSize = 20) {
    try {
      const documents = await this.repository.findDocuments(filters, page, pageSize);
      const totalCount = await this.repository.countDocuments(filters);
      
      return {
        documents,
        pagination: {
          page,
          pageSize,
          totalCount,
          totalPages: Math.ceil(totalCount / pageSize)
        }
      };
    } catch (error) {
      throw new DocumentFetchError(
        'list_error',
        `Error listing documents: ${error.message}`,
        { filters }
      );
    }
  }
  
  /**
   * Check document cache for a previously fetched document
   */
  async _checkDocumentCache(formId, jurisdiction, agency) {
    try {
      const document = await this.repository.getDocument(formId, jurisdiction, agency);
      
      if (!document) {
        return null;
      }
      
      // Check if document is still fresh
      const metadata = document.metadata;
      const now = new Date();
      const lastUpdated = new Date(metadata.lastUpdated);
      const cacheTTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
      
      if (now - lastUpdated > cacheTTL) {
        // Cache is stale, return null to trigger a fresh fetch
        return null;
      }
      
      return document;
    } catch (error) {
      console.error(`Cache check error: ${error.message}`);
      // On cache error, return null to trigger a fresh fetch
      return null;
    }
  }
  
  /**
   * Cache a document for future requests
   */
  async _cacheDocument(document) {
    try {
      await this.repository.addOrUpdateDocument(
        document.document,
        document.metadata
      );
    } catch (error) {
      // Log but don't fail the overall operation
      console.error(`Error caching document: ${error.message}`);
    }
  }
  
  /**
   * Get source configuration based on jurisdiction and agency
   */
  _getSourceConfig(jurisdiction, agency) {
    // Handle federal sources
    if (jurisdiction === 'federal') {
      return config.sources.federal[agency.toLowerCase()];
    }
    
    // Handle state sources (2-letter state codes)
    if (jurisdiction.length === 2 && jurisdiction !== 'US') {
      return config.sources.states[jurisdiction]?.[agency.toLowerCase()];
    }
    
    // Handle territory sources
    const territories = ['PR', 'VI', 'GU', 'AS', 'MP'];
    if (territories.includes(jurisdiction)) {
      return config.sources.territories[jurisdiction]?.[agency.toLowerCase()];
    }
    
    // Handle local sources
    if (jurisdiction.startsWith('local_')) {
      // Extract state from local jurisdiction code (format: local_STATE_123)
      const statePart = jurisdiction.split('_')[1];
      if (statePart && config.sources.states[statePart]) {
        return config.sources.states[statePart].local?.[agency.toLowerCase()];
      }
    }
    
    return null;
  }
  
  /**
   * Fetch document using an API
   */
  async _fetchFromApi(apiEndpoint, formId, requestId) {
    console.log(`[${requestId}] Attempting API fetch from ${apiEndpoint}`);
    
    // Implement retry logic
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
      try {
        const response = await this.httpClient.get(`${apiEndpoint}/${formId}`);
        
        if (response.status === 200) {
          console.log(`[${requestId}] API fetch successful`);
          return {
            document: response.data.document,
            metadata: this._extractMetadataFromApiResponse(response.data, formId)
          };
        } else {
          console.log(`[${requestId}] API returned status ${response.status}`);
          retryCount++;
          
          if (retryCount === maxRetries) {
            throw new Error(`API returned status ${response.status} after ${maxRetries} attempts`);
          }
          
          // Exponential backoff
          await this._sleep(Math.pow(2, retryCount) * 1000);
        }
      } catch (error) {
        console.log(`[${requestId}] API request failed: ${error.message}`);
        retryCount++;
        
        if (retryCount === maxRetries) {
          throw error;
        }
        
        // Exponential backoff
        await this._sleep(Math.pow(2, retryCount) * 1000);
      }
    }
  }
  
  /**
   * Fetch document by scraping the agency website
   */
  async _fetchFromWebsite(baseUrl, formId, jurisdiction, agency, requestId) {
    console.log(`[${requestId}] Attempting web scraping from ${baseUrl}`);
    
    // Choose the appropriate scraper
    const scraper = this.scrapers[agency.toLowerCase()] || this.scrapers.default;
    
    // Enhance scraper with context information
    scraper.setContext({
      formId,
      jurisdiction,
      agency,
      requestId
    });
    
    // Scrape the document and its metadata
    return await scraper.scrapeDocument(baseUrl, formId, jurisdiction);
  }
  
  /**
   * Fetch document from archive as fallback
   */
  async _fetchFromArchive(formId, jurisdiction, agency, requestId) {
    console.log(`[${requestId}] Attempting archive fetch for ${formId}`);
    
    // Query the archive database
    const archivedDocument = await this.repository.getArchivedDocument(formId, jurisdiction, agency);
    
    if (!archivedDocument) {
      throw new Error(`No archived document found for ${formId} from ${jurisdiction}/${agency}`);
    }
    
    // Update metadata to indicate this is from archive
    archivedDocument.metadata.retrievedFromArchive = true;
    archivedDocument.metadata.archiveTimestamp = new Date().toISOString();
    
    return archivedDocument;
  }
  
  /**
   * Process and enhance a document with AI
   */
  async _processDocument(document, formId, jurisdiction, agency, requestId) {
    console.log(`[${requestId}] Processing document ${formId}`);
    
    // Apply document processing
    const processedDocument = await this.documentProcessor.process(document);
    
    // Add additional metadata
    processedDocument.metadata.lastUpdated = new Date().toISOString();
    processedDocument.metadata.processingId = requestId;
    
    // Extract and enhance metadata from document content
    if (!processedDocument.metadata.documentType) {
      processedDocument.metadata.documentType = await this.documentProcessor.detectDocumentType(processedDocument.document);
    }
    
    // Extract form fields if not already present
    if (!processedDocument.metadata.formFields) {
      processedDocument.metadata.formFields = await this.documentProcessor.extractFormFields(processedDocument.document);
    }
    
    return processedDocument;
  }
  
  /**
   * Extract metadata from an API response
   */
  _extractMetadataFromApiResponse(apiData, formId) {
    return new DocumentMetadata(
      formId,
      apiData.jurisdiction,
      apiData.agency,
      apiData.formType,
      apiData.version,
      apiData.lastUpdated,
      apiData.effectiveDate,
      apiData.expirationDate
    );
  }
  
  /**
   * Generate a unique request ID
   */
  _generateRequestId() {
    return `fetch-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
  }
  
  /**
   * Sleep for a specified number of milliseconds
   */
  _sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * DocumentMonitorService - Monitors documents for updates and compliance
 */
class DocumentMonitorService {
  constructor() {
    this.repository = new DocumentRepository();
    this.fetcher = new DocumentFetchService();
    this.scheduler = new ScheduleManager();
    this.notificationService = new NotificationService();
    this.webhookService = new WebhookService();
    
    // Initialize AI-powered monitoring
    this.complianceAnalyzer = new ComplianceAnalyzer();
    this.updateDetector = new DocumentUpdateDetector();
  }
  
  /**
   * Initialize monitoring schedules for different document types
   */
  initializeSchedules() {
    // Set up daily checks for high-priority documents
    this.scheduler.scheduleJob(config.schedulingFrequency.dailyCheck, () => {
      this.checkHighPriorityDocuments();
    });
    
    // Set up monthly checks for all documents
    this.scheduler.scheduleJob(config.schedulingFrequency.monthlyCheck, () => {
      this.checkAllDocuments();
    });
    
    // Set up annual comprehensive review
    this.scheduler.scheduleJob(config.schedulingFrequency.annualCheck, () => {
      this.performAnnualReview();
    });
    
    // Set up quarterly checks for tax-related documents
    this.scheduler.scheduleJob(config.schedulingFrequency.quarterlyCheck, () => {
      this.checkTaxDocuments();
    });
  }
  
  /**
   * Get document status
   */
  async getDocumentStatus(formId, jurisdiction, agency) {
    try {
      const metadata = await this.repository.getDocumentMetadata(formId, jurisdiction, agency);
      
      if (!metadata) {
        throw new DocumentFetchError(
          'document_not_found',
          `Document ${formId} from ${jurisdiction}/${agency} not found`,
          { formId, jurisdiction, agency }
        );
      }
      
      // Check if document needs updating
      const needsUpdate = metadata.needsUpdate();
      
      return {
        formId: metadata.formId,
        jurisdiction: metadata.jurisdiction,
        agency: metadata.agency,
        currentVersion: metadata.currentVersion,
        lastUpdated: metadata.lastUpdated,
        effectiveDate: metadata.effectiveDate,
        expirationDate: metadata.expirationDate,
        isActive: metadata.isActive,
        lastChecked: metadata.lastChecked,
        needsUpdate,
        formType: metadata.formType,
        changeLog: metadata.changeLog
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'status_error',
          `Error getting document status: ${error.message}`,
          { formId, jurisdiction, agency }
        );
      }
    }
  }
  
  /**
   * Manually refresh a document to get the latest version
   */
  async refreshDocument(formId, jurisdiction, agency) {
    try {
      console.log(`Manual refresh requested for ${formId} from ${jurisdiction}/${agency}`);
      
      // Get the current stored metadata
      const storedMetadata = await this.repository.getDocumentMetadata(formId, jurisdiction, agency);
      
      if (!storedMetadata) {
        console.log(`No stored metadata for ${formId}. Fetching as new document.`);
        const newDoc = await this.fetcher.fetchDocument(formId, jurisdiction, agency);
        await this.repository.addOrUpdateDocument(newDoc.document, newDoc.metadata);
        
        return {
          formId,
          jurisdiction,
          agency,
          currentVersion: newDoc.metadata.currentVersion,
          lastUpdated: newDoc.metadata.lastUpdated,
          lastChecked: new Date().toISOString(),
          status: 'added',
          message: 'New document fetched successfully'
        };
      }
      
      // Fetch the latest version from source
      const latestDoc = await this.fetcher.fetchDocument(formId, jurisdiction, agency);
      
      // Compare versions to detect changes
      const hasChanged = this._hasDocumentChanged(storedMetadata, latestDoc.metadata);
      
      if (hasChanged) {
        console.log(`Document ${formId} has been updated. Storing new version.`);
        
        // Log the change
        const changeType = this._determineChangeType(storedMetadata, latestDoc.metadata);
        latestDoc.metadata.logChange(
          new Date().toISOString(),
          changeType,
          `Updated from version ${storedMetadata.currentVersion} to ${latestDoc.metadata.currentVersion}`
        );
        
        // Store the updated document
        await this.repository.updateDocument(formId, jurisdiction, agency, latestDoc.document, latestDoc.metadata);
        
        // Trigger notifications
        await this._notifyDocumentUpdate(formId, jurisdiction, agency, storedMetadata, latestDoc.metadata);
        
        return {
          formId,
          jurisdiction,
          agency,
          currentVersion: latestDoc.metadata.currentVersion,
          lastUpdated: latestDoc.metadata.lastUpdated,
          lastChecked: new Date().toISOString(),
          status: 'updated',
          changeType,
          message: 'Document updated successfully'
        };
      } else {
        console.log(`No changes detected for ${formId}`);
        
        // Update last checked timestamp
        await this.repository.updateLastChecked(formId, jurisdiction, agency);
        
        return {
          formId,
          jurisdiction,
          agency,
          currentVersion: storedMetadata.currentVersion,
          lastUpdated: storedMetadata.lastUpdated,
          lastChecked: new Date().toISOString(),
          status: 'unchanged',
          message: 'Document is already up to date'
        };
      }
    } catch (error) {
      throw new DocumentFetchError(
        'refresh_error',
        `Error refreshing document: ${error.message}`,
        { formId, jurisdiction, agency }
      );
    }
  }
  
  /**
   * Check company compliance
   */
  async checkCompanyCompliance(companyId) {
    try {
      // Get company profile
      const companyProfile = await companyService.getCompanyProfile(companyId);
      
      if (!companyProfile) {
        throw new DocumentFetchError(
          'company_not_found',
          `Company ${companyId} not found`,
          { companyId }
        );
      }
      
      // Get required documents
      const requiredDocs = await integrationService.getRequiredDocuments(
        companyProfile.jurisdiction,
        companyProfile.size,
        companyProfile.type,
        companyProfile.hasEmployees,
        companyProfile.hasForeignWorkers
      );
      
      // Get company document status
      const documentStatus = await this.repository.getCompanyDocumentStatus(companyId);
      
      // Use AI-powered compliance analyzer to calculate compliance
      const complianceStatus = await this.complianceAnalyzer.calculateComplianceStatus(
        requiredDocs,
        documentStatus,
        companyProfile
      );
      
      return {
        companyId,
        requiredDocuments: requiredDocs.length,
        completedDocuments: documentStatus.filter(doc => doc.status === 'completed').length,
        compliancePercentage: complianceStatus.percentage,
        complianceStatus: complianceStatus.status,
        documentStatus,
        complianceDetails: complianceStatus.details,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'compliance_check_error',
          `Error checking company compliance: ${error.message}`,
          { companyId }
        );
      }
    }
  }
  
  /**
   * Check employee compliance
   */
  async checkEmployeeCompliance(employeeId) {
    try {
      // Get employee profile
      const employeeProfile = await employeeService.getEmployeeProfile(employeeId);
      
      if (!employeeProfile) {
        throw new DocumentFetchError(
          'employee_not_found',
          `Employee ${employeeId} not found`,
          { employeeId }
        );
      }
      
      // Get employee onboarding checklist
      const checklist = await this.repository.getEmployeeChecklist(employeeId);
      
      if (!checklist) {
        throw new DocumentFetchError(
          'checklist_not_found',
          `Checklist not found for employee ${employeeId}`,
          { employeeId }
        );
      }
      
      // Get checklist items
      const checklistItems = await this.repository.getChecklistItems(checklist.id);
      
      // Calculate compliance status
      const complianceStatus = await this.complianceAnalyzer.calculateEmployeeCompliance(
        checklistItems,
        employeeProfile
      );
      
      return {
        employeeId,
        totalItems: checklistItems.length,
        completedItems: checklistItems.filter(item => item.status === 'completed').length,
        requiredItems: checklistItems.filter(item => item.required).length,
        completedRequiredItems: checklistItems.filter(item => item.required && item.status === 'completed').length,
        compliancePercentage: complianceStatus.percentage,
        complianceStatus: complianceStatus.status,
        complianceDetails: complianceStatus.details,
        checklist: {
          id: checklist.id,
          status: checklist.status,
          createdAt: checklist.createdAt,
          updatedAt: checklist.updatedAt,
          completedAt: checklist.completedAt,
          items: checklistItems
        },
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'compliance_check_error',
          `Error checking employee compliance: ${error.message}`,
          { employeeId }
        );
      }
    }
  }
  
  /**
   * Get document update analytics
   */
  async getDocumentUpdateAnalytics(filters) {
    try {
      // Get document updates
      const documentUpdates = await this.repository.getDocumentUpdates(filters);
      
      // Process analytics
      const analytics = {
        totalUpdates: documentUpdates.length,
        updatesByJurisdiction: {},
        updatesByAgency: {},
        updatesByMonth: {},
        majorUpdates: 0,
        minorUpdates: 0,
        updatesByDocumentType: {},
        timeTrends: []
      };
      
      // Group analytics by various dimensions
      for (const update of documentUpdates) {
        // Count by jurisdiction
        analytics.updatesByJurisdiction[update.jurisdiction] = 
          (analytics.updatesByJurisdiction[update.jurisdiction] || 0) + 1;
        
        // Count by agency
        analytics.updatesByAgency[update.agency] = 
          (analytics.updatesByAgency[update.agency] || 0) + 1;
        
        // Count by month
        const updateMonth = update.lastUpdated.substring(0, 7); // YYYY-MM
        analytics.updatesByMonth[updateMonth] = 
          (analytics.updatesByMonth[updateMonth] || 0) + 1;
        
        // Count by document type
        if (update.formType) {
          analytics.updatesByDocumentType[update.formType] = 
            (analytics.updatesByDocumentType[update.formType] || 0) + 1;
        }
        
        // Count by change type
        if (update.changeLog && update.changeLog.length > 0) {
          const latestChange = update.changeLog[update.changeLog.length - 1];
          if (latestChange.type === 'major') {
            analytics.majorUpdates++;
          } else {
            analytics.minorUpdates++;
          }
        }
      }
      
      // Calculate time trends
      const monthsInOrder = Object.keys(analytics.updatesByMonth).sort();
      for (const month of monthsInOrder) {
        analytics.timeTrends.push({
          month,
          count: analytics.updatesByMonth[month]
        });
      }
      
      return analytics;
    } catch (error) {
      throw new DocumentFetchError(
        'analytics_error',
        `Error getting document update analytics: ${error.message}`,
        { filters }
      );
    }
  }
  
  /**
   * Get compliance analytics
   */
  async getComplianceAnalytics(filters) {
    try {
      // Get company compliance data
      const companyCompliance = await this.repository.getCompanyComplianceData(filters);
      
      // Process analytics
      const analytics = {
        totalCompanies: companyCompliance.length,
        compliantCompanies: 0,
        partiallyCompliantCompanies: 0,
        nonCompliantCompanies: 0,
        complianceByJurisdiction: {},
        complianceByCompanySize: {
          small: { total: 0, compliant: 0 },
          medium: { total: 0, compliant: 0 },
          large: { total: 0, compliant: 0 }
        },
        complianceByIndustry: {},
        trendData: [],
        complianceRiskAreas: []
      };
      
      // Calculate analytics
      for (const company of companyCompliance) {
        // Count by compliance status
        if (company.complianceStatus === 'compliant') {
          analytics.compliantCompanies++;
        } else if (company.complianceStatus === 'partially_compliant') {
          analytics.partiallyCompliantCompanies++;
        } else {
          analytics.nonCompliantCompanies++;
        }
        
        // Count by jurisdiction
        if (!analytics.complianceByJurisdiction[company.jurisdiction]) {
          analytics.complianceByJurisdiction[company.jurisdiction] = {
            total: 0,
            compliant: 0
          };
        }
        analytics.complianceByJurisdiction[company.jurisdiction].total++;
        if (company.complianceStatus === 'compliant') {
          analytics.complianceByJurisdiction[company.jurisdiction].compliant++;
        }
        
        // Count by company size
        let sizeCategory = 'small';
        if (company.size >= 50 && company.size < 250) {
          sizeCategory = 'medium';
        } else if (company.size >= 250) {
          sizeCategory = 'large';
        }
        
        analytics.complianceByCompanySize[sizeCategory].total++;
        if (company.complianceStatus === 'compliant') {
          analytics.complianceByCompanySize[sizeCategory].compliant++;
        }
        
        // Count by industry
        if (company.industry) {
          if (!analytics.complianceByIndustry[company.industry]) {
            analytics.complianceByIndustry[company.industry] = {
              total: 0,
              compliant: 0
            };
          }
          analytics.complianceByIndustry[company.industry].total++;
          if (company.complianceStatus === 'compliant') {
            analytics.complianceByIndustry[company.industry].compliant++;
          }
        }
      }
      
      // Calculate percentages
      for (const jurisdiction in analytics.complianceByJurisdiction) {
        const data = analytics.complianceByJurisdiction[jurisdiction];
        analytics.complianceByJurisdiction[jurisdiction].percentage = 
          data.total > 0 ? (data.compliant / data.total) * 100 : 0;
      }
      
      for (const size in analytics.complianceByCompanySize) {
        const data = analytics.complianceByCompanySize[size];
        analytics.complianceByCompanySize[size].percentage = 
          data.total > 0 ? (data.compliant / data.total) * 100 : 0;
      }
      
      for (const industry in analytics.complianceByIndustry) {
        const data = analytics.complianceByIndustry[industry];
        analytics.complianceByIndustry[industry].percentage = 
          data.total > 0 ? (data.compliant / data.total) * 100 : 0;
      }
      
      // Calculate overall compliance percentage
      analytics.overallCompliancePercentage = 
        analytics.totalCompanies > 0 ? (analytics.compliantCompanies / analytics.totalCompanies) * 100 : 0;
      
      // Identify risk areas using AI analysis
      analytics.complianceRiskAreas = await this.complianceAnalyzer.identifyRiskAreas(companyCompliance);
      
      // Generate trend data
      analytics.trendData = await this.repository.getComplianceHistoricalData(filters);
      
      return analytics;
    } catch (error) {
      throw new DocumentFetchError(
        'analytics_error',
        `Error getting compliance analytics: ${error.message}`,
        { filters }
      );
    }
  }
  
  /**
   * Register a webhook for notifications
   */
  async registerWebhook(clientId, url, events, secret) {
    try {
      // Validate webhook URL
      if (!this._isValidUrl(url)) {
        throw new DocumentFetchError(
          'invalid_webhook_url',
          'The provided webhook URL is invalid',
          { url }
        );
      }
      
      // Validate event types
      const validEvents = ['document_update', 'compliance_alert', 'expiration_warning'];
      for (const event of events) {
        if (!validEvents.includes(event)) {
          throw new DocumentFetchError(
            'invalid_event_type',
            `Invalid event type: ${event}. Valid event types are: ${validEvents.join(', ')}`,
            { event }
          );
        }
      }
      
      // Create or update webhook
      const webhook = await this.webhookService.register(clientId, url, events, secret);
      
      return {
        webhookId: webhook.id,
        url: webhook.url,
        events: webhook.events,
        created: webhook.createdAt
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'webhook_registration_error',
          `Error registering webhook: ${error.message}`,
          { clientId, url, events }
        );
      }
    }
  }
  
  /**
   * Get registered webhooks for a client
   */
  async getWebhooks(clientId) {
    try {
      return await this.webhookService.getWebhooks(clientId);
    } catch (error) {
      throw new DocumentFetchError(
        'webhook_get_error',
        `Error getting webhooks: ${error.message}`,
        { clientId }
      );
    }
  }
  
  /**
   * Delete a webhook
   */
  async deleteWebhook(clientId, webhookId) {
    try {
      await this.webhookService.deleteWebhook(clientId, webhookId);
    } catch (error) {
      throw new DocumentFetchError(
        'webhook_delete_error',
        `Error deleting webhook: ${error.message}`,
        { clientId, webhookId }
      );
    }
  }
  
  /**
   * Check if a document has changed
   */
  _hasDocumentChanged(storedMetadata, newMetadata) {
    // Compare version numbers
    if (storedMetadata.currentVersion !== newMetadata.currentVersion) {
      return true;
    }
    
    // Compare content hashes
    if (storedMetadata.documentHash !== newMetadata.documentHash) {
      return true;
    }
    
    // Compare effective dates
    if (storedMetadata.effectiveDate !== newMetadata.effectiveDate) {
      return true;
    }
    
    // Compare expiration dates
    if (storedMetadata.expirationDate !== newMetadata.expirationDate) {
      return true;
    }
    
    // Use AI-powered update detector for subtle changes
    if (this.updateDetector.detectChanges(storedMetadata, newMetadata)) {
      return true;
    }
    
    return false;
  }
  
  /**
   * Determine the type of change (minor, major, revision)
   */
  _determineChangeType(oldMetadata, newMetadata) {
    // Version number change pattern analysis
    const oldVersionParts = oldMetadata.currentVersion.split('.');
    const newVersionParts = newMetadata.currentVersion.split('.');
    
    if (oldVersionParts[0] !== newVersionParts[0]) {
      return 'major'; // Major version number changed
    } else if (oldVersionParts.length > 1 && newVersionParts.length > 1 && 
               oldVersionParts[1] !== newVersionParts[1]) {
      return 'revision'; // Minor version number changed
    } else {
      // Use AI to analyze the significance of changes
      const changeImportance = this.updateDetector.analyzeChangeImportance(oldMetadata, newMetadata);
      
      return changeImportance > 0.7 ? 'revision' : 'minor';
    }
  }
  
  /**
   * Notify relevant parties about document updates
   */
  async _notifyDocumentUpdate(formId, jurisdiction, agency, oldMetadata, newMetadata) {
    // Prepare notification data
    const notificationData = {
      type: 'document_update',
      formId,
      jurisdiction,
      agency,
      oldVersion: oldMetadata.currentVersion,
      newVersion: newMetadata.currentVersion,
      effectiveDate: newMetadata.effectiveDate,
      changeType: this._determineChangeType(oldMetadata, newMetadata),
      timestamp: new Date().toISOString()
    };
    
    // Notify system administrators
    await this.notificationService.notifyAdmins(notificationData);
    
    // Get affected customers
    const affectedUsers = await this.repository.getUsersAffectedByForm(formId, jurisdiction);
    
    // Notify each affected user
    for (const user of affectedUsers) {
      await this.notificationService.notifyUser(user.id, {
        type: 'document_update',
        formId,
        formName: this._getFormDisplayName(formId, jurisdiction),
        action: 'update_required',
        effectiveDate: newMetadata.effectiveDate,
        timestamp: new Date().toISOString()
      });
    }
    
    // Send webhook notifications
    await this.webhookService.sendWebhookNotifications('document_update', notificationData);
    
    // Log the notification
    console.log(`Sent document update notifications for ${formId} to ${affectedUsers.length} users`);
  }
  
  /**
   * Get a user-friendly display name for a form
   */
  _getFormDisplayName(formId, jurisdiction) {
    // Convert technical form IDs to user-friendly names
    const formNames = {
      'W-4': 'Employee\'s Withholding Certificate',
      'I-9': 'Employment Eligibility Verification',
      'W-2': 'Wage and Tax Statement',
      '941': 'Employer\'s Quarterly Federal Tax Return',
      'W-9': 'Request for Taxpayer Identification Number',
      '1099-NEC': 'Nonemployee Compensation',
      'SS-4': 'Application for Employer Identification Number'
    };
    
    // Add jurisdiction-specific prefix for non-federal forms
    if (jurisdiction !== 'federal' && formId in formNames) {
      return `${jurisdiction.toUpperCase()} ${formNames[formId]}`;
    }
    
    return formNames[formId] || formId;
  }
  
  /**
   * Validate URL format
   */
  _isValidUrl(string) {
    try {
      new URL(string);
      return true;
    } catch (_) {
      return false;
    }
  }
}

/**
 * Integration Service - Manages integration with external systems
 */
class IntegrationService {
  constructor() {
    this.repository = new DocumentRepository();
    this.onboardingWorkflow = new OnboardingWorkflow(this.repository);
    this.documentFetcher = new DocumentFetchService();
  }
  
  /**
   * Get required documents based on company profile
   */
  async getRequiredDocuments(jurisdiction, companySize, companyType, hasEmployees, hasForeignWorkers) {
    try {
      // Define document requirements based on company profile
      const requiredDocs = [];
      
      // Federal forms required for all employers
      if (hasEmployees) {
        requiredDocs.push(
          { formId: 'I-9', jurisdiction: 'federal', agency: 'uscis', required: true, priority: 'high' },
          { formId: 'W-4', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'high' }
        );
        
        // Add state-specific forms
        if (jurisdiction !== 'federal') {
          // Get state withholding form equivalent
          const stateWithholdingForm = await this.repository.findOne(
            'state_specific_forms',
            { jurisdiction, type: 'withholding' }
          );
          
          if (stateWithholdingForm) {
            requiredDocs.push({
              formId: stateWithholdingForm.formId,
              jurisdiction,
              agency: stateWithholdingForm.agency,
              required: true,
              priority: 'high'
            });
          }
          
          // Get state new hire reporting form
          const stateNewHireForm = await this.repository.findOne(
            'state_specific_forms',
            { jurisdiction, type: 'new_hire_reporting' }
          );
          
          if (stateNewHireForm) {
            requiredDocs.push({
              formId: stateNewHireForm.formId,
              jurisdiction,
              agency: stateNewHireForm.agency,
              required: true,
              priority: 'high'
            });
          }
        }
      }
      
      // Tax reporting forms
      requiredDocs.push(
        { formId: '941', jurisdiction: 'federal', agency: 'irs', required: hasEmployees, priority: 'medium' },
        { formId: '940', jurisdiction: 'federal', agency: 'irs', required: hasEmployees, priority: 'medium' },
        { formId: 'W-2', jurisdiction: 'federal', agency: 'irs', required: hasEmployees, priority: 'medium' },
        { formId: 'W-3', jurisdiction: 'federal', agency: 'irs', required: hasEmployees, priority: 'medium' }
      );
      
      // Independent contractor forms
      requiredDocs.push(
        { formId: 'W-9', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' },
        { formId: '1099-NEC', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' },
        { formId: '1096', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' }
      );
      
      // ACA forms for large employers
      if (companySize >= 50) {
        requiredDocs.push(
          { formId: '1095-C', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' },
          { formId: '1094-C', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' }
        );
      }
      
      // Foreign worker documentation
      if (hasForeignWorkers) {
        requiredDocs.push(
          { formId: 'W-8BEN', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'high' },
          { formId: '1042-S', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'medium' }
        );
      }
      
      // Specific forms based on company type
      if (companyType === 'nonprofit') {
        requiredDocs.push(
          { formId: '990', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'high' }
        );
      } else if (companyType === 'partnership') {
        requiredDocs.push(
          { formId: '1065', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'high' }
        );
      } else if (companyType === 'corporation') {
        requiredDocs.push(
          { formId: '1120', jurisdiction: 'federal', agency: 'irs', required: true, priority: 'high' }
        );
      }
      
      // Get territory-specific requirements
      if (['PR', 'VI', 'GU', 'AS', 'MP'].includes(jurisdiction)) {
        const territoryDocs = await this.repository.find(
          'territory_specific_forms',
          { jurisdiction, companyType }
        );
        
        for (const doc of territoryDocs) {
          requiredDocs.push({
            formId: doc.formId,
            jurisdiction,
            agency: doc.agency,
            required: doc.required,
            priority: doc.priority
          });
        }
      }
      
      // Fetch the current metadata for each required document
      const enhancedDocs = await Promise.all(
        requiredDocs.map(async (doc) => {
          try {
            const metadata = await this.repository.getDocumentMetadata(
              doc.formId,
              doc.jurisdiction,
              doc.agency
            );
            
            if (metadata) {
              return {
                ...doc,
                currentVersion: metadata.currentVersion,
                effectiveDate: metadata.effectiveDate,
                expirationDate: metadata.expirationDate,
                lastUpdated: metadata.lastUpdated
              };
            }
            
            return doc;
          } catch (error) {
            console.error(`Error fetching metadata for ${doc.formId}: ${error.message}`);
            return doc;
          }
        })
      );
      
      return enhancedDocs;
    } catch (error) {
      throw new DocumentFetchError(
        'required_documents_error',
        `Error getting required documents: ${error.message}`,
        { jurisdiction, companySize, companyType, hasEmployees, hasForeignWorkers }
      );
    }
  }
  
  /**
   * Start company onboarding process
   */
  async startCompanyOnboarding(companyData) {
    try {
      console.log(`Starting onboarding workflow for company ${companyData.name}`);
      
      // Validate required fields
      if (!companyData.name || !companyData.taxId || !companyData.jurisdiction) {
        throw new DocumentFetchError(
          'invalid_company_data',
          'Company name, taxId, and jurisdiction are required',
          { companyData }
        );
      }
      
      // Start the onboarding workflow
      const result = await this.onboardingWorkflow.startCompanyOnboarding(companyData);
      
      return result;
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'onboarding_error',
          `Error starting company onboarding: ${error.message}`,
          { companyData }
        );
      }
    }
  }
  
  /**
   * Start employee onboarding process
   */
  async startEmployeeOnboarding(employeeData) {
    try {
      console.log(`Starting onboarding workflow for employee ${employeeData.name}`);
      
      // Validate required fields
      if (!employeeData.name || !employeeData.companyId) {
        throw new DocumentFetchError(
          'invalid_employee_data',
          'Employee name and companyId are required',
          { employeeData }
        );
      }
      
      // Start the onboarding workflow
      const result = await this.onboardingWorkflow.startEmployeeOnboarding(employeeData);
      
      return result;
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'onboarding_error',
          `Error starting employee onboarding: ${error.message}`,
          { employeeData }
        );
      }
    }
  }
  
  /**
   * Update document status during onboarding
   */
  async updateDocumentStatus(checklistItemId, status, fileId = null) {
    try {
      // Validate status
      const validStatuses = ['pending', 'in_progress', 'completed', 'waived', 'rejected'];
      if (!validStatuses.includes(status)) {
        throw new DocumentFetchError(
          'invalid_status',
          `Invalid status: ${status}. Valid statuses are: ${validStatuses.join(', ')}`,
          { checklistItemId, status }
        );
      }
      
      // Update the document status
      const result = await this.onboardingWorkflow.updateDocumentStatus(checklistItemId, status, fileId);
      
      return result;
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'status_update_error',
          `Error updating document status: ${error.message}`,
          { checklistItemId, status, fileId }
        );
      }
    }
  }
  
  /**
   * Get integration status for a client
   */
  async getIntegrationStatus(clientId) {
    try {
      const integrationInfo = await this.repository.getClientIntegration(clientId);
      
      if (!integrationInfo) {
        return {
          clientId,
          integrated: false,
          message: 'No integration configured'
        };
      }
      
      // Check integration health
      const healthCheck = await this._checkIntegrationHealth(integrationInfo);
      
      return {
        clientId,
        integrated: true,
        integrationType: integrationInfo.type,
        lastSync: integrationInfo.lastSync,
        status: healthCheck.status,
        message: healthCheck.message,
        documentCount: healthCheck.documentCount,
        companyCount: healthCheck.companyCount,
        employeeCount: healthCheck.employeeCount
      };
    } catch (error) {
      throw new DocumentFetchError(
        'integration_status_error',
        `Error getting integration status: ${error.message}`,
        { clientId }
      );
    }
  }
  
  /**
   * Configure integration settings
   */
  async configureIntegration(clientId, settings) {
    try {
      // Validate integration type
      const validTypes = ['api', 'webhook', 'sftp', 'database'];
      if (!settings.type || !validTypes.includes(settings.type)) {
        throw new DocumentFetchError(
          'invalid_integration_type',
          `Invalid integration type. Valid types are: ${validTypes.join(', ')}`,
          { settings }
        );
      }
      
      // Validate required settings for each type
      switch (settings.type) {
        case 'api':
          if (!settings.apiUrl || !settings.apiKey) {
            throw new DocumentFetchError(
              'missing_api_settings',
              'API integration requires apiUrl and apiKey',
              { settings }
            );
          }
          break;
        case 'webhook':
          if (!settings.webhookUrl || !settings.secret) {
            throw new DocumentFetchError(
              'missing_webhook_settings',
              'Webhook integration requires webhookUrl and secret',
              { settings }
            );
          }
          break;
        case 'sftp':
          if (!settings.host || !settings.username) {
            throw new DocumentFetchError(
              'missing_sftp_settings',
              'SFTP integration requires host and username',
              { settings }
            );
          }
          break;
        case 'database':
          if (!settings.connectionString || !settings.schema) {
            throw new DocumentFetchError(
              'missing_database_settings',
              'Database integration requires connectionString and schema',
              { settings }
            );
          }
          break;
      }
      
      // Test the integration
      const testResult = await this._testIntegration(settings);
      
      if (!testResult.success) {
        throw new DocumentFetchError(
          'integration_test_failed',
          `Integration test failed: ${testResult.message}`,
          { settings }
        );
      }
      
      // Save integration settings
      await this.repository.saveClientIntegration(clientId, {
        ...settings,
        status: 'active',
        lastSync: null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
      
      return {
        clientId,
        integrated: true,
        integrationType: settings.type,
        status: 'active',
        message: 'Integration configured successfully',
        testResult: testResult.details
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'integration_configuration_error',
          `Error configuring integration: ${error.message}`,
          { clientId, settings }
        );
      }
    }
  }
  
  /**
   * Check integration health
   */
  async _checkIntegrationHealth(integrationInfo) {
    try {
      // Implement health checks based on integration type
      switch (integrationInfo.type) {
        case 'api':
          // Test API connectivity
          const apiResponse = await fetch(integrationInfo.apiUrl, {
            method: 'HEAD',
            headers: {
              'Authorization': `Bearer ${integrationInfo.apiKey}`
            }
          });
          
          return {
            status: apiResponse.ok ? 'healthy' : 'error',
            message: apiResponse.ok ? 'API connection successful' : `API error: ${apiResponse.status}`,
            documentCount: await this.repository.getClientDocumentCount(integrationInfo.clientId),
            companyCount: await this.repository.getClientCompanyCount(integrationInfo.clientId),
            employeeCount: await this.repository.getClientEmployeeCount(integrationInfo.clientId)
          };
        
        // Implement checks for other integration types
        default:
          return {
            status: 'unknown',
            message: `Health check not implemented for ${integrationInfo.type} integration`,
            documentCount: 0,
            companyCount: 0,
            employeeCount: 0
          };
      }
    } catch (error) {
      return {
        status: 'error',
        message: `Health check failed: ${error.message}`,
        documentCount: 0,
        companyCount: 0,
        employeeCount: 0
      };
    }
  }
  
  /**
   * Test integration configuration
   */
  async _testIntegration(settings) {
    try {
      // Implement tests based on integration type
      switch (settings.type) {
        case 'api':
          // Test API connectivity
          const apiResponse = await fetch(settings.apiUrl, {
            method: 'HEAD',
            headers: {
              'Authorization': `Bearer ${settings.apiKey}`
            }
          });
          
          return {
            success: apiResponse.ok,
            message: apiResponse.ok ? 'API connection successful' : `API error: ${apiResponse.status}`,
            details: {
              statusCode: apiResponse.status,
              statusText: apiResponse.statusText
            }
          };
        
        // Implement tests for other integration types
        default:
          return {
            success: false,
            message: `Test not implemented for ${settings.type} integration`,
            details: {}
          };
      }
    } catch (error) {
      return {
        success: false,
        message: `Integration test failed: ${error.message}`,
        details: { error: error.message }
      };
    }
  }
}

/**
 * JurisdictionService - Service for managing jurisdiction information
 */
class JurisdictionService {
  constructor() {
    this.repository = new DocumentRepository();
    this.cache = new CacheService();
  }
  
  /**
   * Get all supported jurisdictions
   */
  async getJurisdictions(tierLevel) {
    try {
      // Check cache first
      const cacheKey = `jurisdictions:tier:${tierLevel}`;
      const cachedData = await this.cache.get(cacheKey);
      
      if (cachedData) {
        return cachedData;
      }
      
      // Filter jurisdictions based on tier level
      const jurisdictions = await this.repository.getAllJurisdictions();
      
      let filteredJurisdictions;
      
      switch (tierLevel) {
        case 'basic':
          // Basic tier gets federal and limited states
          filteredJurisdictions = jurisdictions.filter(j => 
            j.type === 'federal' || 
            (j.type === 'state' && this._isBasicTierState(j.code))
          );
          break;
          
        case 'standard':
          // Standard tier gets federal and all states
          filteredJurisdictions = jurisdictions.filter(j => 
            j.type === 'federal' || j.type === 'state'
          );
          break;
          
        case 'professional':
          // Professional tier gets federal, all states, and limited local
          filteredJurisdictions = jurisdictions.filter(j => 
            j.type === 'federal' || 
            j.type === 'state' || 
            this._isLimitedLocalJurisdiction(j)
          );
          break;
          
        case 'enterprise':
          // Enterprise tier gets everything
          filteredJurisdictions = jurisdictions;
          break;
          
        default:
          // Default to basic tier
          filteredJurisdictions = jurisdictions.filter(j => 
            j.type === 'federal' || 
            (j.type === 'state' && this._isBasicTierState(j.code))
          );
      }
      
      // Cache the filtered results
      await this.cache.set(cacheKey, filteredJurisdictions, 3600); // 1 hour TTL
      
      return filteredJurisdictions;
    } catch (error) {
      throw new JurisdictionError(
        'jurisdictions_fetch_error',
        `Error fetching jurisdictions: ${error.message}`
      );
    }
  }
  
  /**
   * Get detailed information for a specific jurisdiction
   */
  async getJurisdictionDetails(jurisdictionId) {
    try {
      // Check cache first
      const cacheKey = `jurisdiction:${jurisdictionId}`;
      const cachedData = await this.cache.get(cacheKey);
      
      if (cachedData) {
        return cachedData;
      }
      
      // Get jurisdiction details
      const jurisdiction = await this.repository.getJurisdiction(jurisdictionId);
      
      if (!jurisdiction) {
        throw new JurisdictionError(
          'jurisdiction_not_found',
          `Jurisdiction ${jurisdictionId} not found`,
          { jurisdictionId }
        );
      }
      
      // Get parent jurisdictions
      const parentJurisdictions = await this.repository.getParentJurisdictions(jurisdictionId);
      
      // Get jurisdiction-specific forms
      const forms = await this.repository.getJurisdictionForms(jurisdictionId);
      
      // Get agencies for this jurisdiction
      const agencies = await this.repository.getJurisdictionAgencies(jurisdictionId);
      
      // Compile the complete jurisdiction details
      const jurisdictionDetails = {
        id: jurisdiction.id,
        name: jurisdiction.name,
        code: jurisdiction.code,
        type: jurisdiction.type,
        parentJurisdictions,
        forms,
        agencies,
        documentCount: forms.length,
        hasLocalJurisdictions: jurisdiction.type === 'state' ? await this._hasLocalJurisdictions(jurisdiction.code) : false
      };
      
      // Cache the results
      await this.cache.set(cacheKey, jurisdictionDetails, 3600); // 1 hour TTL
      
      return jurisdictionDetails;
    } catch (error) {
      if (error instanceof JurisdictionError) {
        throw error;
      } else {
        throw new JurisdictionError(
          'jurisdiction_details_error',
          `Error fetching jurisdiction details: ${error.message}`,
          { jurisdictionId }
        );
      }
    }
  }
  
  /**
   * Check if a state is included in the basic tier
   */
  _isBasicTierState(stateCode) {
    // Basic tier only includes major states
    const basicTierStates = [
      'CA', 'TX', 'FL', 'NY', 'IL', 
      'PA', 'OH', 'GA', 'NC', 'MI'
    ];
    
    return basicTierStates.includes(stateCode);
  }
  
  /**
   * Check if a jurisdiction is included in limited local jurisdictions
   */
  _isLimitedLocalJurisdiction(jurisdiction) {
    // Professional tier only includes major local jurisdictions
    if (jurisdiction.type !== 'county' && jurisdiction.type !== 'city') {
      return false;
    }
    
    // Major cities and counties
    const majorJurisdictions = [
      'CTY_NY_NEWYORK', 'CTY_CA_LOSANGELES', 'CTY_IL_CHICAGO',
      'CTY_TX_HOUSTON', 'CTY_AZ_PHOENIX', 'CTY_PA_PHILADELPHIA',
      'CTY_TX_SANANTONIO', 'CTY_CA_SANDIEGO', 'CTY_TX_DALLAS',
      'CTY_CA_SANJOSE',
      
      'CNT_CA_LOSANGELES', 'CNT_IL_COOK', 'CNT_TX_HARRIS',
      'CNT_AZ_MARICOPA', 'CNT_CA_SANDIEGO', 'CNT_TX_DALLAS',
      'CNT_NY_QUEENS', 'CNT_NY_KINGS', 'CNT_CA_ORANGE',
      'CNT_FL_MIAMI_DADE'
    ];
    
    return majorJurisdictions.includes(jurisdiction.id);
  }
  
  /**
   * Check if a state has local jurisdictions
   */
  async _hasLocalJurisdictions(stateCode) {
    const localCount = await this.repository.countLocalJurisdictions(stateCode);
    return localCount > 0;
  }
}

/**
 * ResourceManagerService - Manages document resources
 */
class ResourceManagerService {
  constructor() {
    this.repository = new DocumentRepository();
    this.fileStorage = new FileStorageService();
    this.documentProcessor = new DocumentProcessor();
  }
  
  /**
   * Get document resources
   */
  async getDocumentResources(filters) {
    try {
      return await this.repository.getDocumentResources(filters);
    } catch (error) {
      throw new DocumentFetchError(
        'resources_fetch_error',
        `Error fetching document resources: ${error.message}`,
        { filters }
      );
    }
  }
  
  /**
   * Get a specific document resource
   */
  async getDocumentResource(resourceId) {
    try {
      const resource = await this.repository.getDocumentResource(resourceId);
      
      if (!resource) {
        throw new DocumentFetchError(
          'resource_not_found',
          `Resource ${resourceId} not found`,
          { resourceId }
        );
      }
      
      // Get download URL
      const downloadUrl = await this.fileStorage.getDownloadUrl(resource.fileId);
      
      return {
        ...resource,
        downloadUrl
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'resource_fetch_error',
          `Error fetching document resource: ${error.message}`,
          { resourceId }
        );
      }
    }
  }
  
  /**
   * Upload a document resource
   */
  async uploadDocumentResource(req) {
    try {
      const { formId, jurisdiction, agency, resourceType, description } = req.body;
      const file = req.file;
      
      if (!formId || !jurisdiction || !agency || !resourceType || !file) {
        throw new DocumentFetchError(
          'missing_parameters',
          'Missing required parameters',
          { formId, jurisdiction, agency, resourceType }
        );
      }
      
      // Process the document to extract metadata and check format
      const processedFile = await this.documentProcessor.processResource(file);
      
      // Upload file to storage
      const fileId = await this.fileStorage.uploadFile(processedFile);
      
      // Create resource record
      const resourceId = await this.repository.createDocumentResource({
        formId,
        jurisdiction,
        agency,
        resourceType,
        description,
        fileId,
        fileName: file.originalname,
        fileSize: file.size,
        fileType: file.mimetype,
        metadata: processedFile.metadata,
        uploadedBy: req.user.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
      
      // Get download URL
      const downloadUrl = await this.fileStorage.getDownloadUrl(fileId);
      
      return {
        resourceId,
        formId,
        jurisdiction,
        agency,
        resourceType,
        description,
        fileId,
        fileName: file.originalname,
        fileType: file.mimetype,
        fileSize: file.size,
        metadata: processedFile.metadata,
        downloadUrl,
        createdAt: new Date().toISOString()
      };
    } catch (error) {
      if (error instanceof DocumentFetchError) {
        throw error;
      } else {
        throw new DocumentFetchError(
          'resource_upload_error',
          `Error uploading document resource: ${error.message}`,
          { body: req.body, file: req.file?.originalname }
        );
      }
    }
  }
}

/**
 * DocumentProcessor - AI-powered document processing
 */
class DocumentProcessor {
  constructor() {
    this.nlpService = new NLPService();
    this.imageProcessor = new ImageProcessor();
    this.textExtractor = new TextExtractor();
  }
  
  /**
   * Process a document with AI enhancements
   */
  async process(document) {
    // Determine document format
    const format = this._detectFormat(document);
    
    // Extract text content if needed
    let textContent = document.document;
    if (format !== 'text') {
      textContent = await this.textExtractor.extract(document.document, format);
    }
    
    // Apply NLP processing
    const enhancedContent = await this.nlpService.enhanceDocument(textContent);
    
    // Update document with enhanced content
    return {
      document: enhancedContent,
      metadata: {
        ...document.metadata,
        processingFormat: format,
        textLength: textContent.length,
        enhancedAt: new Date().toISOString(),
        contentHash: this._generateHash(enhancedContent)
      }
    };
  }
  
  /**
   * Process a resource file
   */
  async processResource(file) {
    // Determine file format
    const format = this._detectFileFormat(file);
    
    // Process based on format
    let processedFile = { ...file };
    
    if (['pdf', 'doc', 'docx'].includes(format)) {
      // Extract text content
      const textContent = await this.textExtractor.extractFromFile(file);
      
      // Extract metadata
      const metadata = await this._extractFileMetadata(file, format, textContent);
      
      processedFile.metadata = metadata;
    } else if (['jpg', 'png', 'tiff'].includes(format)) {
      // Process image
      processedFile = await this.imageProcessor.process(file);
    }
    
    return processedFile;
  }
  
  /**
   * Detect document type
   */
  async detectDocumentType(documentContent) {
    // Use NLP to classify document type
    return await this.nlpService.classifyDocumentType(documentContent);
  }
  
  /**
   * Extract form fields from document
   */
  async extractFormFields(documentContent) {
    // Use NLP to extract form fields
    return await this.nlpService.extractFormFields(documentContent);
  }
  
  /**
   * Detect document format
   */
  _detectFormat(document) {
    if (typeof document.document === 'string') {
      return 'text';
    } else if (document.document instanceof Buffer) {
      // Check for PDF signature
      if (document.document.slice(0, 4).toString() === '%PDF') {
        return 'pdf';
      }
      // Check for other formats...
    }
    
    return 'unknown';
  }
  
  /**
   * Detect file format
   */
  _detectFileFormat(file) {
    const extension = file.originalname.split('.').pop().toLowerCase();
    
    const formatMap = {
      'pdf': 'pdf',
      'doc': 'doc',
      'docx': 'docx',
      'txt': 'text',
      'jpg': 'jpg',
      'jpeg': 'jpg',
      'png': 'png',
      'tiff': 'tiff',
      'tif': 'tiff'
    };
    
    return formatMap[extension] || 'unknown';
  }
  
  /**
   * Extract metadata from file
   */
  async _extractFileMetadata(file, format, textContent) {
    // Extract basic metadata
    const metadata = {
      format,
      fileName: file.originalname,
      fileSize: file.size,
      mimeType: file.mimetype,
      extractedAt: new Date().toISOString()
    };
    
    // Add text-based metadata if text was extracted
    if (textContent) {
      metadata.textLength = textContent.length;
      metadata.contentHash = this._generateHash(textContent);
      
      // Classify document type
      metadata.documentType = await this.nlpService.classifyDocumentType(textContent);
      
      // Extract possible form fields
      metadata.formFields = await this.nlpService.extractFormFields(textContent);
    }
    
    return metadata;
  }
  
  /**
   * Generate content hash
   */
  _generateHash(content) {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(content).digest('hex');
  }
}

/**
 * DocumentMetadata - Model for document metadata
 */
class DocumentMetadata {
  constructor(formId, jurisdiction, agency, formType, currentVersion, lastUpdated, effectiveDate, expirationDate) {
    this.formId = formId;                 // Unique identifier for the form (e.g., "W-4", "I-9")
    this.jurisdiction = jurisdiction;     // Federal, state code, or territory code
    this.agency = agency;                 // Issuing agency (IRS, SSA, state tax board, etc.)
    this.formType = formType;             // Tax, employment, benefits, compliance, etc.
    this.currentVersion = currentVersion; // Current version identifier (often year-based)
    this.lastUpdated = lastUpdated;       // When this form was last updated
    this.effectiveDate = effectiveDate;   // When this form version becomes effective
    this.expirationDate = expirationDate; // When this form version expires (if applicable)
    this.changeLog = [];                  // History of changes to this document
    this.sourceUrl = null;                // URL to official source of the document
    this.documentHash = null;             // Content hash to detect changes
    this.isActive = true;                 // Whether this form is currently in effect
    this.lastChecked = new Date().toISOString(); // When this form was last checked for updates
  }
  
  /**
   * Add a change to the changelog
   */
  logChange(changeDate, changeType, changeDescription) {
    this.changeLog.push({
      date: changeDate,
      type: changeType, // 'minor', 'major', 'revision', etc.
      description: changeDescription
    });
  }
  
  /**
   * Check if this document is current or needs updating
   */
  needsUpdate(currentDate = new Date()) {
    // Check if document has expired
    if (this.expirationDate && new Date(this.expirationDate) < currentDate) {
      return true;
    }
    
    // Check if document hasn't been checked in a while
    const lastCheckedDate = new Date(this.lastChecked);
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    if (lastCheckedDate < thirtyDaysAgo) {
      return true;
    }
    
    // Additional logic for determining if a form needs updating
    // For example, known form update schedules
    if (this.formId === 'W-4' && this.currentVersion !== new Date().getFullYear().toString()) {
      return true;
    }
    
    return false;
  }
}

/**
 * Error classes
 */

class DocumentFetchError extends Error {
  constructor(code, message, details = null) {
    super(message);
    this.name = 'DocumentFetchError';
    this.code = code;
    this.details = details;
  }
}

class JurisdictionError extends Error {
  constructor(code, message, details = null) {
    super(message);
    this.name = 'JurisdictionError';
    this.code = code;
    this.details = details;
  }
}

// Export the services
module.exports = {
  DocumentFetchService,
  DocumentMonitorService,
  IntegrationService,
  JurisdictionService,
  ResourceManagerService,
  DocumentProcessor,
  DocumentMetadata,
  DocumentFetchError,
  JurisdictionError
};
