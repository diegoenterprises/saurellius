// services/locationService.js - Location validation and geocoding service

const axios = require('axios');
const { LocationError } = require('../utils/errors');
const { dbQuery } = require('../database/taxDatabase');
const config = require('../config');

/**
 * Service for handling location validation, geocoding, and jurisdiction determination
 */
class LocationService {
  /**
   * Validate an address and return normalized form with tax jurisdiction information
   * @param {Object} address - Address to validate
   * @returns {Object} Normalized address with jurisdiction information
   */
  async validateLocation(address) {
    try {
      // Validate required address fields
      if (!address || !address.street1 || !address.city || !address.state || !address.zipCode) {
        throw new LocationError(
          'invalid_address',
          'Address must include street1, city, state, and zipCode'
        );
      }
      
      // First check if we've already geocoded this exact address
      const cachedLocation = await this._checkAddressCache(address);
      if (cachedLocation) {
        return cachedLocation;
      }
      
      // Normalize the address format
      const normalizedAddress = this._normalizeAddress(address);
      
      // Geocode the address using our geocoding provider
      const geocodeResult = await this._geocodeAddress(normalizedAddress);
      
      // Determine tax jurisdictions based on geocoded coordinates
      const jurisdictions = await this._determineJurisdictions(
        geocodeResult.latitude,
        geocodeResult.longitude,
        normalizedAddress.state
      );
      
      // Generate Saurellius location code
      const locationCode = this._generateLocationCode(jurisdictions);
      
      // Create the complete location result
      const locationResult = {
        normalizedAddress: {
          street1: normalizedAddress.street1,
          street2: normalizedAddress.street2 || '',
          city: normalizedAddress.city,
          state: normalizedAddress.state,
          zipCode: normalizedAddress.zipCode,
          county: geocodeResult.county || ''
        },
        locationCode,
        taxJurisdictions: jurisdictions,
        geocode: {
          latitude: geocodeResult.latitude,
          longitude: geocodeResult.longitude,
          precision: geocodeResult.precision
        },
        state: normalizedAddress.state
      };
      
      // Cache the result for future use
      await this._cacheAddressResult(normalizedAddress, locationResult);
      
      return locationResult;
    } catch (error) {
      if (error instanceof LocationError) {
        throw error;
      } else {
        throw new LocationError(
          'location_service_error',
          `Failed to validate location: ${error.message}`,
          error
        );
      }
    }
  }
  
  /**
   * Retrieve location information by Saurellius location code
   * @param {string} locationCode - Saurellius location code
   * @returns {Object} Location information
   */
  async getLocationByCode(locationCode) {
    try {
      // Validate location code format
      if (!this._isValidLocationCode(locationCode)) {
        throw new LocationError(
          'invalid_location_code',
          'Invalid location code format. Expected format: SS-CCC-FFFFFFFF'
        );
      }
      
      // Parse the location code components
      const [stateId, countyId, featureId] = locationCode.split('-');
      
      // Query the database for location information
      const query = `
        SELECT * FROM locations
        WHERE state_id = ? AND county_id = ? AND feature_id = ?
      `;
      
      const results = await dbQuery(query, [stateId, countyId, featureId]);
      
      if (results.length === 0) {
        throw new LocationError(
          'location_code_not_found',
          `Location code ${locationCode} not found`
        );
      }
      
      const locationData = results[0];
      
      // Get jurisdiction information for this location
      const jurisdictions = await this._getJurisdictionsByLocation(locationCode);
      
      // Construct the response
      return {
        normalizedAddress: {
          city: locationData.city,
          state: locationData.state,
          county: locationData.county
        },
        locationCode,
        taxJurisdictions: jurisdictions,
        geocode: {
          latitude: locationData.latitude,
          longitude: locationData.longitude
        },
        state: locationData.state
      };
    } catch (error) {
      if (error instanceof LocationError) {
        throw error;
      } else {
        throw new LocationError(
          'location_code_error',
          `Failed to get location by code: ${error.message}`,
          error
        );
      }
    }
  }
  
  /**
   * Check if we've already geocoded this address
   * @param {Object} address - Address to check
   * @returns {Object|null} Cached location result or null
   */
  async _checkAddressCache(address) {
    try {
      // Create a normalized representation for cache lookup
      const cacheKey = this._createAddressCacheKey(address);
      
      // Query the address cache
      const query = 'SELECT result FROM address_cache WHERE cache_key = ?';
      const results = await dbQuery(query, [cacheKey]);
      
      if (results.length > 0) {
        // Parse the JSON result
        return JSON.parse(results[0].result);
      }
      
      return null;
    } catch (error) {
      // If there's an error with the cache, just return null and proceed with geocoding
      console.error('Address cache check failed:', error);
      return null;
    }
  }
  
  /**
   * Cache an address geocoding result
   * @param {Object} address - Normalized address
   * @param {Object} result - Location result to cache
   */
  async _cacheAddressResult(address, result) {
    try {
      const cacheKey = this._createAddressCacheKey(address);
      const resultJson = JSON.stringify(result);
      
      // Insert or replace in the cache
      const query = `
        INSERT INTO address_cache (cache_key, result, created_at) 
        VALUES (?, ?, CURRENT_TIMESTAMP)
        ON DUPLICATE KEY UPDATE result = ?, created_at = CURRENT_TIMESTAMP
      `;
      
      await dbQuery(query, [cacheKey, resultJson, resultJson]);
    } catch (error) {
      // Log the error but don't fail the overall operation
      console.error('Failed to cache address result:', error);
    }
  }
  
  /**
   * Create a cache key for an address
   * @param {Object} address - Address to create key for
   * @returns {string} Cache key
   */
  _createAddressCacheKey(address) {
    // Create a consistent string representation for cache lookups
    const addressParts = [
      address.street1,
      address.street2 || '',
      address.city,
      address.state,
      address.zipCode
    ];
    
    // Join and normalize whitespace, case, etc.
    return addressParts
      .join('|')
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .trim();
  }
  
  /**
   * Normalize address format
   * @param {Object} address - Address to normalize
   * @returns {Object} Normalized address
   */
  _normalizeAddress(address) {
    // Make a copy to avoid modifying the original
    const normalized = { ...address };
    
    // Normalize state to uppercase
    normalized.state = normalized.state.toUpperCase();
    
    // Format zip code
    normalized.zipCode = normalized.zipCode.replace(/[^0-9]/g, '');
    
    // Normalize city name (title case)
    normalized.city = this._toTitleCase(normalized.city);
    
    // Normalize street (title case and abbreviate common terms)
    normalized.street1 = this._normalizeStreet(normalized.street1);
    
    if (normalized.street2) {
      normalized.street2 = this._normalizeStreet(normalized.street2);
    }
    
    return normalized;
  }
  
  /**
   * Normalize street address formatting
   * @param {string} street - Street address to normalize
   * @returns {string} Normalized street address
   */
  _normalizeStreet(street) {
    // Title case the street
    let normalized = this._toTitleCase(street);
    
    // Common street abbreviations
    const abbreviations = {
      'Street': 'St',
      'Avenue': 'Ave',
      'Boulevard': 'Blvd',
      'Drive': 'Dr',
      'Road': 'Rd',
      'Lane': 'Ln',
      'Court': 'Ct',
      'Circle': 'Cir',
      'Place': 'Pl',
      'Highway': 'Hwy',
      'Parkway': 'Pkwy',
      'Apartment': 'Apt',
      'Suite': 'Ste',
      'Building': 'Bldg',
      'North': 'N',
      'South': 'S',
      'East': 'E',
      'West': 'W',
      'Northeast': 'NE',
      'Northwest': 'NW',
      'Southeast': 'SE',
      'Southwest': 'SW'
    };
    
    // Replace full words with abbreviations
    for (const [full, abbr] of Object.entries(abbreviations)) {
      const regex = new RegExp(`\\b${full}\\b`, 'gi');
      normalized = normalized.replace(regex, abbr);
    }
    
    return normalized;
  }
  
  /**
   * Convert a string to title case
   * @param {string} text - Text to convert
   * @returns {string} Title cased text
   */
  _toTitleCase(text) {
    return text
      .toLowerCase()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
  
  /**
   * Geocode an address using external geocoding service
   * @param {Object} address - Normalized address to geocode
   * @returns {Object} Geocoding result with coordinates and precision
   */
  async _geocodeAddress(address) {
    try {
      // Construct the address string for geocoding
      const addressString = [
        address.street1,
        address.street2,
        address.city,
        address.state,
        address.zipCode
      ]
        .filter(Boolean)
        .join(', ');
      
      // Call external geocoding service
      const response = await axios.get(config.geocoding.apiUrl, {
        params: {
          address: addressString,
          key: config.geocoding.apiKey
        }
      });
      
      // Process the geocoding response
      if (!response.data || response.data.status !== 'OK') {
        throw new Error(`Geocoding failed: ${response.data?.status || 'Unknown error'}`);
      }
      
      const result = response.data.results[0];
      
      // Extract county information from address components
      let county = '';
      for (const component of result.address_components) {
        if (component.types.includes('administrative_area_level_2')) {
          county = component.long_name;
          break;
        }
      }
      
      // Determine precision level
      let precision = 'unknown';
      if (result.geometry.location_type === 'ROOFTOP') {
        precision = 'rooftop';
      } else if (result.geometry.location_type === 'RANGE_INTERPOLATED') {
        precision = 'interpolated';
      } else if (result.partial_match) {
        precision = 'partial';
      } else {
        precision = 'approximate';
      }
      
      return {
        latitude: result.geometry.location.lat,
        longitude: result.geometry.location.lng,
        county,
        precision
      };
    } catch (error) {
      throw new LocationError(
        'geocoding_error',
        `Failed to geocode address: ${error.message}`,
        error
      );
    }
  }
  
  /**
   * Determine tax jurisdictions based on coordinates
   * @param {number} latitude - Latitude coordinate
   * @param {number} longitude - Longitude coordinate
   * @param {string} state - State code
   * @returns {Array} Array of tax jurisdictions
   */
  async _determineJurisdictions(latitude, longitude, state) {
    try {
      // Query the database for jurisdictions at these coordinates
      const query = `
        SELECT 
          j.jurisdiction_id,
          j.jurisdiction_name,
          j.jurisdiction_type,
          j.jurisdiction_code,
          j.parent_jurisdiction_id,
          j.residence_based
        FROM 
          jurisdiction_boundaries jb
          JOIN jurisdictions j ON jb.jurisdiction_id = j.jurisdiction_id
        WHERE 
          ST_Contains(jb.boundary, ST_Point(?, ?))
          AND j.state_code = ?
        ORDER BY 
          j.jurisdiction_type
      `;
      
      const results = await dbQuery(query, [longitude, latitude, state]);
      
      // If no jurisdictions found, fall back to state-level only
      if (results.length === 0) {
        // Get the state jurisdiction
        const stateQuery = `
          SELECT 
            jurisdiction_id,
            jurisdiction_name,
            jurisdiction_type,
            jurisdiction_code,
            parent_jurisdiction_id,
            residence_based
          FROM 
            jurisdictions
          WHERE 
            jurisdiction_type = 'state'
            AND state_code = ?
        `;
        
        const stateResults = await dbQuery(stateQuery, [state]);
        
        if (stateResults.length === 0) {
          throw new Error(`No jurisdiction found for state: ${state}`);
        }
        
        return stateResults.map(this._mapJurisdictionRow);
      }
      
      return results.map(this._mapJurisdictionRow);
    } catch (error) {
      throw new LocationError(
        'jurisdiction_error',
        `Failed to determine jurisdictions: ${error.message}`,
        error
      );
    }
  }
  
  /**
   * Get jurisdiction information by location code
   * @param {string} locationCode - Saurellius location code
   * @returns {Array} Array of tax jurisdictions
   */
  async _getJurisdictionsByLocation(locationCode) {
    try {
      // Parse the location code to get state, county, and feature IDs
      const [stateId, countyId, featureId] = locationCode.split('-');
      
      // Query the database for jurisdictions by location components
      const query = `
        SELECT 
          j.jurisdiction_id,
          j.jurisdiction_name,
          j.jurisdiction_type,
          j.jurisdiction_code,
          j.parent_jurisdiction_id,
          j.residence_based
        FROM 
          jurisdictions j
          JOIN jurisdiction_locations jl ON j.jurisdiction_id = jl.jurisdiction_id
        WHERE 
          jl.state_id = ?
          AND (jl.county_id = ? OR jl.county_id IS NULL)
          AND (jl.feature_id = ? OR jl.feature_id IS NULL)
        ORDER BY 
          j.jurisdiction_type
      `;
      
      const results = await dbQuery(query, [stateId, countyId, featureId]);
      
      if (results.length === 0) {
        throw new Error(`No jurisdictions found for location code: ${locationCode}`);
      }
      
      return results.map(this._mapJurisdictionRow);
    } catch (error) {
      throw new LocationError(
        'jurisdiction_location_error',
        `Failed to get jurisdictions by location: ${error.message}`,
        error
      );
    }
  }
  
  /**
   * Map a database row to a jurisdiction object
   * @param {Object} row - Database row
   * @returns {Object} Jurisdiction object
   */
  _mapJurisdictionRow(row) {
    return {
      jurisdictionId: row.jurisdiction_id,
      jurisdictionName: row.jurisdiction_name,
      jurisdictionType: row.jurisdiction_type,
      jurisdictionCode: row.jurisdiction_code,
      parentJurisdictionId: row.parent_jurisdiction_id,
      residenceBased: row.residence_based === 1
    };
  }
  
  /**
   * Generate a Saurellius location code from jurisdictions
   * @param {Array} jurisdictions - Array of tax jurisdictions
   * @returns {string} Saurellius location code
   */
  _generateLocationCode(jurisdictions) {
    // Find the state jurisdiction
    const state = jurisdictions.find(j => j.jurisdictionType === 'state');
    if (!state) {
      throw new LocationError(
        'missing_state_jurisdiction',
        'Could not find state jurisdiction'
      );
    }
    
    // Find the county jurisdiction
    const county = jurisdictions.find(j => j.jurisdictionType === 'county');
    if (!county) {
      throw new LocationError(
        'missing_county_jurisdiction',
        'Could not find county jurisdiction'
      );
    }
    
    // Find the most specific locality (city, town, etc.)
    const localities = jurisdictions.filter(j => 
      ['city', 'town', 'village', 'township', 'municipality'].includes(j.jurisdictionType)
    );
    
    let featureId = '00000000'; // Default if no specific locality
    
    if (localities.length > 0) {
      // Use the first locality (they should be ordered by specificity)
      const locality = localities[0];
      
      // Extract the feature ID from the jurisdiction code
      const match = locality.jurisdictionCode.match(/\d{8}$/);
      if (match) {
        featureId = match[0];
      }
    }
    
    // Extract state ID from state code
    const stateId = state.jurisdictionCode.padStart(2, '0');
    
    // Extract county ID from county code
    const countyId = county.jurisdictionCode.slice(-3).padStart(3, '0');
    
    // Combine to form the location code: SS-CCC-FFFFFFFF
    return `${stateId}-${countyId}-${featureId}`;
  }
  
  /**
   * Validate a location code format
   * @param {string} locationCode - Location code to validate
   * @returns {boolean} Whether the code is valid
   */
  _isValidLocationCode(locationCode) {
    // Location code format: SS-CCC-FFFFFFFF
    // SS = 2-digit state ID
    // CCC = 3-digit county ID
    // FFFFFFFF = 8-digit feature ID
    const regex = /^\d{2}-\d{3}-\d{8}$/;
    return regex.test(locationCode);
  }
}

module.exports = new LocationService();
